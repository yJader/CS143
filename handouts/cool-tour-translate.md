以下是PDF文件内容的完整翻译，以Markdown格式呈现：

# A Tour of the Cool Support Code

## 1 Introduction

Cool编译器项目提供了一些基本数据类型，以便在课程的时间范围内使编写Cool编译器变得可行。本文档概述了Cool编译器支持代码，包括以下内容：

- 链表数据类型；
- 字符串表包；
- 符号表包；
- 用于解析器和词法分析器的杂项工具；
- 用于管理Cool抽象语法树的包；
- 打印抽象语法树的例程；
- 处理多个输入文件和命令行标志的杂项例程；
- 运行时系统。

本文档应与源代码一起阅读。除了抽象语法树包（它是自动生成的）之外，源代码中还有大量的注释。Cool支持代码的目的是易于理解和使用。系统中使用的大多数数据结构有更高效的实现。建议学生在实现Cool编译器时也坚持使用简单、明显正确且可能效率低下的实现——编写正确工作的编译器通常已经足够困难了。Cool系统用C++编写，假设读者对这种语言有一定的熟悉度。基础系统故意使用语言的简单子集。大量使用的特性包括：类、单一继承、虚拟函数和模板。重载使用得非常节制；除了一个例外（例外是操作符<<），操作符重载被完全避免。没有使用析构函数，事实上，内存管理被完全忽略。内存管理是当前工业实践中软件开发非常重要的一部分，但内存管理也容易出错，且非常耗时。建议学生在编写自己的Cool编译器时也不要担心内存管理。

## 2 Lists

文件list.h实现了一个简单的链表数据类型。操作类似于Lisp家族语言中提供的：构造函数List在列表的前面添加一个新元素，hd返回列表的第一个元素，tl返回列表的尾部。还提供了计算列表长度、对列表每个元素应用函数和打印列表的函数。在字符串表和符号表的实现中可以找到列表的使用示例。

## 3 String Tables

所有编译器都管理大量的字符串，如程序标识符、数值常量和字符串常量。通常，这些字符串中的许多是相同的。例如，每个标识符在程序中通常出现多次。为了确保字符串常量紧凑存储和高效操作，使用了一种专门的数据结构——字符串表。字符串表是一个查找表，维护每个字符串的单一副本。Cool字符串表类提供了多种方式插入和查询字符串表的方法（参见文件stringtab.h）。虽然生产编译器使用哈希数据结构实现字符串表，但Cool字符串表是作为列表实现的（参见stringtab functions.h）。Cool字符串表的组件类型为Entry。每个Entry存储一个字符串、字符串的长度和一个唯一的整型索引。Cool编译器结构的一个重要点实际上是三个不同的字符串表：一个用于字符串常量（stringtable）、一个用于整型常量（inttable）和一个用于标识符（idtable）。代码生成器必须区分整型常量和字符串常量以及标识符，因为程序中每个字符串常量和每个整型常量都会生成特殊代码。拥有三个不同的字符串表使得这种区分变得容易。请注意，这三个表中的每一个都有一个不同的元素类型（StrEntry、IntEntry和IdEntry），每一个都是Entry的派生类。在编译器的其余部分（除了代码生成器的部分）中，指向Entry的指针被称为Symbol，无论Symbol表示的是整数、字符串还是标识符。因为字符串表只存储每个字符串的一个副本，所以比较两个IntEntrys、StrEntrys或IdEntrys x和y是否表示相同的字符串可以通过比较两个指针x == y来简单地完成。请注意，比较不同字符串表中的条目是没有意义的（例如，IntEntrys与StrEntrys），因为即使字符串相同，这些条目也保证是不同的。提供了三种方法向表中添加元素：add string(char *s,int m)，添加最多m个字符的字符串s；add string(char *s)，将字符串s添加到表中；和add int(int i)，将整数i转换为字符串并添加到表中。这些方法返回一个从Entry派生的类型，用于描述符号表条目，在该方法上定义了get string，用于提取条目的字符串。在使用这些函数之前，应阅读stringtab.cc中的文档。如果你不正确使用字符串表管理器的接口，你的程序可能会崩溃。

## 4 Symbol Tables

除了字符串，编译器还必须确定和管理程序名称的作用域。符号表是用于管理作用域的数据结构。概念上，符号表只是另一个查找表。键是符号（名称），结果是与该符号关联的任何信息（例如，符号的类型）。

除了添加和删除符号之外，符号表还支持进入和退出作用域的操作，以及检查当前作用域中是否已经定义了标识符。查找操作还必须遵守语言的作用域规则；如果有多个标识符x的定义，作用域规则决定查找x返回哪个定义。在大多数语言中，包括Cool在内，内部定义隐藏外部定义。因此，对x的查找返回具有x定义的最内部作用域的定义。Cool符号表实现为作用域的列表，每个作用域是⟨标识符，数据⟩对的列表。"数据"是程序员希望与每个标识符关联的任何数据。符号表操作在这种结构上定义非常简单，并在symtab.h中记录。symtab example.cc文件中有一个示例说明了符号表的使用。

## 5 Utilities

文件utilities.h和utilities.cc定义了一些在编写和调试Cool解析器和词法分析器时有用的函数。有关文档，请参见源代码。

## 6 Abstract Syntax Trees

词法分析和解析之后，Cool程序在内部由Cool编译器表示为抽象语法树。项目附带了内置的Cool抽象语法树（AST）的定义。AST包是基础系统中最大的代码块，也是学习时间最长的。学习过程更加复杂，因为AST代码是从cool-tree.aps文件中的规范自动生成的。虽然生成的代码结构简单且规则，但也缺乏注释。本节作为AST包的文档。

### 6.1 Phyla and Constructors

AST数据类型为每种Cool结构提供了一个类，用于表示该类型的表达式。有一个类用于let表达式，另一个类用于+表达式，等等。这些类的实例是Cool抽象语法树中的节点。例如，表达式e1 + e2由一个+表达式对象表示，该对象有两个子树：一个表示表达式e1的树，一个表示表达式e2的树。Cool抽象语法是在一种称为APS的语言中指定的。在APS术语中，各种类型的抽象语法树节点（let、+等）称为构造函数。（不要将这里的“构造函数”与C++构造函数混淆；虽然相似，但这是来自功能语言的一个稍不同的含义，这种含义早于C++。）AST的形式由一组phyla描述。每个phylum有一个或多个构造函数。Phyla实际上只是类型。也就是说，不是有一个大型的未分化的构造函数组，而是根据功能将构造函数分组，例如，表达式AST的构造函数与类AST的构造函数区分开来。phyla在cool-tree.aps的开头定义：

```c++
module COOL begin
    phylum Program;
    phylum Class_;
    phylum Classes = LIST[Class_];
    phylum Feature; phylum Features = LIST[Feature];
    phylum Formal; phylum Formals = LIST[Formal];
    phylum Expression; phylum Expressions = LIST[Expression];
    phylum Case; phylum Cases = LIST[Case];
```

从定义中可以看出，有两种不同类型的phyla："normal" phyla和list phyla。"Normal" phyla每个都有关联的构造函数；list phyla有一组固定的列表操作。每个构造函数接受类型参数并返回类型结果。类型可以是phyla或任何普通的C++类型。实际上，phyla声明本身是由APS编译器编译成C++类声明的。一个示例构造函数定义是：

```c++
constructor class_(name : Symbol; parent: Symbol; features : Features; filename : Symbol) : Class_;
```

这个声明指定类构造函数1接受四个参数：一个Symbol（类型标识符）用于类名，一个Symbol（另一个类型标识符）用于父类，一个Features，以及一个Symbol用于类定义发生的文件名。phylum Features被定义为Feature的列表：

```c++
phylum Features = LIST[Feature];
```

有关AST列表上定义的操作的描述，请参见第??节。类构造函数返回一个类型（或phylum）为Class的AST。在cool.y中有一个使用类构造函数的例子：

```c++
class : CLASS TYPEID INHERITS TYPEID IS optional_feature_list END ’;’ { $$ = class_($2,$4,$6,stringtable.add_string(curr_filename)); }
```

类构造函数使用四个参数作为子节点构建了一个Class树节点。因为参数的phyla（类型）已经声明，C++类型检查器强制类构造函数只应用于适当类型的参数。有关其他构造函数的定义，请参见第??节和cool-tree.aps。

有一个真正的危险是，因为相同的名称在不同上下文中重复用于不同的实体，所以容易混淆。在上面的例子中，名称class的微小变化用于终端（CLASS）、非终端（class）、构造函数（class）和phylum（Class）。这些使用都是不同的，并且意味着不同的事情。还有cool.y中的一个联合声明类成员，它意味着另外一些事情。大多数使用都通过大写字母进行一致区分，但有一些不是。在阅读代码时，重要的是要记住每个符号的角色。

1. 为了避免与C++关键字class冲突，选择了名称class。
2. cool-tree.aps中的注释以两个连字符“--”开头。

### 6.2 AST Lists

List phyla有一组独特的操作用于构建和访问列表。请注意，AST包使用自己的列表定义，这与list.h中定义的列表类型不同，并且具有不同的操作。对于每个名为X的phylum，都有一个名为Xs的phylum（除了Classes，它是由Class节点组成的列表），类型为List[X]。为每个列表自动定义了列表函数。对于Class phylum，一些列表函数和方法包括：

```c++
Classes nil_Classes(); // 返回一个空的phylum列表
Classes single_Classes(Class_); // 从其phylum参数创建长度为1的列表
Classes append_Classes(Classes,Classes); // 连接两个phylum列表
Class_ nth(int index); // 选择其列表参数的第index个元素
int len(); // 返回列表的长度
```

这些函数对任何对Lisp或Scheme有基本了解的人都会感到熟悉。函数nil phylums()返回一个空的phylum列表。函数single phylums将其phylum参数转换为长度为1的列表。函数append phylums连接两个phylum列表。方法nth选择其列表参数的第index个元素。方法len返回列表的长度。AST列表还有一个简单的列表迭代器。有一个方法first返回列表第一个元素的索引，一个谓词more在其索引参数是列表的最后一个元素时返回false，以及一个方法next返回列表的下一个索引。这个迭代器相当简单且效率低下；要找到列表的第n个元素，必须检查列表中多达n个元素。然而，它易于理解和使用。列表函数在cool-X-tree.h和tree.h中定义。使用迭代器函数遍历列表l的典型用法是：

```c++
for(int i = l->first(); l->more(i); i = l->next(i)) { ... do something with l->nth(i) ... }
```

### 6.3 The AST Class Hierarchy

除了列表之外，所有AST类都派生自tree node类。所有列表都是tree节点的列表。TreeNode类和AST列表模板在tree.h中定义。TreeNode类定义包含了抽象语法树节点所需的一切，除了特定于特定构造函数的信息。有一个受保护的数据成员行号，即AST节点对应的表达式在源文件中出现的行号。行号被Cool编译器用来提供良好的错误信息。在所有树节点上定义了几个函数。重要的函数包括：dump，它打印一个AST并获取行号，这是一个选择器，用于相应的数据成员。每个phylum都是直接从TreeNode派生的类。如前所述，phylum主要用来将相关构造函数分组在一起，因此没有增加太多新功能。每个构造函数都是从相应的phylum派生的类。每个构造函数类定义了一个同名函数，可以用来构建AST节点。dump函数也自动为每个构造函数定义。

### 6.4 Class Members

树包的每个类定义都附带了一些成员。一些成员函数在上面已经讨论过。本节描述了数据成员和一些其他函数（但不是全部），以及如何向类添加新成员。每个构造函数都有为其构造函数的每个组件定义的数据成员。成员的名称是构造函数中字段的名称，并且仅对构造函数的类或派生类的成员函数可见。例如，类构造函数有四个数据成员：

```c++
Symbol name;
Symbol parent;
Features features;
Symbol filename;
```

这是一个成员的完整用法：

```c++
class__class c;
Symbol p;
Symbol class__class::get_parent() { return parent; }
c = class(idtable.add_string("Foo",3),idtable.add_string("Bar"),nil_Features(), stringtable.add_string("filename"));
p = c->get_parent(); // 设置p为"Bar"的符号
```

在编写Cool编译器时，将AST扩展为新函数（如get parent）将会很有用。只需修改cool-tree.h文件，以向适当phylum或构造函数的类添加函数。

### 6.5 The Constructors

本节简要描述了每个构造函数及其在编译器中的作用。每个构造函数对应Cool语法的一部分。构造函数的参数顺序遵循Cool语法规范中产生式中符号出现的顺序。构造函数与程序语法之间的这种对应关系应该清楚地说明了如何使用构造函数的参数。与cool-tree.aps一起阅读本节可能会有所帮助。

- program：在解析结束时应用于类的最后一组列表。这个构造函数的唯一需要用法已经在cool.y的框架中。
- class：这个构造函数从两种类型和一组特性构建一个类节点。参见上面的示例。
- method：这是Feature phylum中的两个构造函数之一。使用这个构造函数来构建方法的AST节点。请注意，第二个参数是形式参数的列表。
- attr：这是属性的构造函数。init字段用于可选的初始化表达式。
- formal：这是方法定义中形式参数的构造函数。字段名称是不言自明的。
- branch：这是Case phylum中唯一的构造函数。一个case表达式的分支具有形式name : typeid => expr；这与字段名称以显而易见的方式对应。使用这个构造函数为case表达式的每个分支构建AST。
- assign：这是赋值表达式的构造函数。
- static dispatch和dispatch：Cool中有两种不同的dispatch，它们有独特的构造函数。参见Cool手册中关于静态与正常dispatch的讨论。注意有一个dispatch的简写，省略了self参数。不要使用no expr构造函数代替self；你需要为编译器的其他部分正确工作填写self的符号。
- cond：这是if-then-else表达式的构造函数。
- loop：这是循环池表达式的构造函数。
- typcase：这个构造函数为case表达式构建AST。请注意，第二个参数是case分支的列表（参见上面的branch构造函数）。
- block：这是{...}块表达式的构造函数。
- let：这是let表达式的构造函数。请注意，let构造函数只允许一个标识符。在解析具有多个标识符的let表达式时，应将其转换为具有单个标识符的嵌套lets，如Cool手册中let的语义所述。
- plus：这是+表达式的构造函数。
- sub：这是-表达式的构造函数。
- mul：这是*表达式的构造函数。
- divide：这是/表达式的构造函数。
- neg：这是~表达式的构造函数。
- lt：这是<表达式的构造函数。
- eq：这是=表达式的构造函数。
- leq：这是<=表达式的构造函数。
- comp：这是not表达式的构造函数。
- int const：这是整数常量的构造函数。
- bool const：这是布尔常量的构造函数。
- string const：这是字符串常量的构造函数。
- new：这是new表达式的构造函数。
- isvoid：这是isvoid表达式的构造函数。
- no expr：这个构造函数不接受参数。在构造函数参数缺失的地方使用no expr，因为省略了可选表达式，除了在dispatch表达式中省略了self（参见上面的dispatch讨论）。

### 6.6 Tips on Using the Tree Package

使用树包时，人们常犯一些错误。

- 树包实现了一个抽象数据类型。违反接口（例如，通过类型转换、指针算术等）会引发灾难。坚持使用定义好的接口。在向类声明添加新成员时，要小心这些成员不会干扰现有函数的接口。
- NULL值不是任何AST的有效组件。永远不要将NULL作为构造函数的参数使用。使用nil phylum创建空列表。
- 所有树节点和列表都是不同的。例如：

  ```c++
  if (x == nil_Expression()) { ... }
  ```

  这样的测试总是错误的，因为nil Expression()每次使用时都会创建一个新的空列表。要检查列表是否为空，请使用len方法（参见tree.h）。
- 同样，与无子节点的树节点进行比较是没有意义的。例如：

  ```c++
  if (x == no_expr()) { ... }
  ```

  这总是错误的，因为no expr每次调用时都会创建一个新的AST。定义一个虚拟方法来确定x的构造函数（参见第??节）。
- 树包函数执行检查以确保树被正确使用。如果检测到什么不好的事情，函数fatal error被调用以终止执行。要确定问题所在，最好使用调试器dbx或gdb。在fatal error上设置断点，并使用where命令找出哪个例程导致了错误。

## 7 The Runtime System

运行时系统由一组手工编码的汇编语言函数组成，这些函数被Cool程序用作子程序。在spim下，运行时系统在文件trap.handler中。使用运行时系统只与代码生成有关，代码生成必须遵守运行时系统提供的接口。运行时系统包含四类例程：

1. 启动代码，调用主程序的main方法；
2. 预定义类的方法代码（Object、IO、String）；
3. Cool程序测试对象相等性和处理运行时错误所需的一些特殊程序；
4. 垃圾收集器。

Cool运行时系统包含在文件[cool root]/lib/trap.handler中；每当spim/xspim被调用时，它会自动加载。文件中的注释解释了如何调用预定义的函数。以下部分描述了Cool运行系统对生成代码的假设，以及运行时系统为生成代码提供了什么。有关Cool程序执行语义的正式描述，请阅读Cool手册的第13节。

### 7.1 Object Header

每个对象的前三个32位字被假定包含一个类标签、对象大小和一个用于分派信息的指针。此外，垃圾收集器要求对象之前的字包含-1；这个字不是对象的一部分。图??显示了一个Cool对象的布局；偏移量以字节为单位给出。垃圾收集标签是-1。类标签是一个32位整数，标识对象的类。运行时系统在基本类对象之间的相等性比较中使用类标签，并在abort函数中用于索引包含每个类名称的表。对象大小字段和垃圾收集器标签由运行时系统维护；只有运行时系统应该创建新对象。然而，原型对象（见下文）必须由代码生成器直接在静态数据区域编码，因此代码生成器应正确初始化原型的对象大小字段和垃圾收集器标签。任何静态生成的对象也必须初始化这些字段。分派指针实际上从未被运行时系统使用。因此，分派信息的结构不是固定的。您应该为您的代码生成器设计分派信息的结构和使用。特别是，分派信息应用于动态分派上调用正确的方法实现。对于Int对象，唯一的属性是整数的32位值。对于Bool对象，唯一的属性是32位值1或0，分别表示真或假。String对象的第一个属性是一个指向Int对象的对象指针，表示字符串的大小。字符串的实际ASCII字符序列从第二个属性（偏移量16）开始，以0结尾，并用0填充到字边界。值void是一个空指针，由32位值0表示。所有未初始化的变量（除了Int、Bool和String类型的变量；参见Cool手册）默认设置为void。

### 7.2 Prototype Objects

在堆中分配一个新对象的唯一方法是使用Object.copy方法。因此，Cool程序中的每个类都必须有一个可以复制的对象。对于Cool程序中的每个类X，代码生成器应在数据区域中生成一个骨架X对象；这个对象是类X的原型。对于每个原型对象，必须正确设置垃圾收集标签、类标签、对象大小和分派信息。对于基本类Int、Bool和String，属性应设置为Cool手册中指定的默认值。对于其他类，原型的属性可以是您认为方便的任何值。

### 7.3 Stack and Register Conventions

运行时系统中的原始方法期望在寄存器$a0和栈上进行参数传递。通常$a0包含分派的self对象。其他参数应在栈的顶部，第一个参数首先被推送（仅适用于String.substr，它接受两个参数）。一些原始运行时过程期望在特定寄存器中进行参数传递。图??显示了运行时系统使用的寄存器。运行时系统可能会修改任何临时寄存器，而不恢复它们（除非对特定例程另有说明）。堆指针用于跟踪堆上的下一个空闲字，限制指针用于跟踪堆的结束位置。这两个寄存器不应被生成的代码修改或使用——它们完全由运行时系统维护。除了$at、$sp、$ra之外，所有其他寄存器保持不变。

### 7.4 Labels Expected

Cool运行时系统引用图??中列出的固定标签。每个条目描述了运行时系统期望在特定标签处找到什么，以及标签应该出现在哪里（代码/数据段）。如果生成的代码包含静态数据区域中定义的Bool对象的定义，则无需初始化Bool类对象的代码。确保生成的代码中这些标签正确的最简单方法是采用以下命名约定：

- `<class>_init` 用于类 `<class>` 的初始化代码
- `<class>.<method>` 用于类 `<class>` 的方法 `<method>` 代码
- `<class>_protObj` 用于类 `<class>` 的原型对象

最后，图??列出了运行时系统中定义的对生成代码感兴趣的标签。

### 7.5 Execution Startup

启动时，会发生以下事项：

1. 在堆上创建Main原型对象的新副本，然后通过调用Main init进行初始化。
   代码生成器必须定义Main init。Main init应执行Main的父类的所有初始化代码，最后执行Main中的属性初始化（如果有）。
2. 控制权转移到Main.main，将新创建的Main对象的指针传递给寄存器$a0。寄存器$ra包含返回地址。
3. 如果从Main.main返回控制权，执行将停止，并显示消息“COOL程序成功执行”。

## 8 The Garbage Collector

Cool运行时环境包括两种不同的垃圾收集器：一个代垃圾收集器和一个停止-复制收集器。代垃圾收集器是用于编程作业的一个；停止-复制收集器目前未使用。代垃圾收集器自动扫描内存，查找可能仍被程序使用的对象，并将它们复制到一个新的（希望更小）内存区域。生成的代码必须包含指定运行时系统应使用几种可能的垃圾收集器配置的定义。位置MemMgr INITIALIZER应包含垃圾收集器的初始化例程的指针，MemMgr COLLECTOR应包含收集器的代码指针。选项包括不收集、代收集或停止-复制收集；有关每种情况的INITIALIZER和COLLECTOR例程的名称，请参见trap.handler中的注释。如果位置MemMgr TEST非零且启用了垃圾收集器，则每次内存分配都会调用垃圾收集器，这对于测试垃圾收集和代码生成是否正确协同工作非常有用。收集器假设堆栈上每个偶数值（如果是有效的堆地址）是指向对象的指针。因此，代码生成器必须确保堆栈上的偶数地址实际上是指向对象的指针。同样，收集器假设对象中的任何值（基本类的对象除外，这些对象被特别处理）是指向对象的指针。收集器作为垃圾收集的一部分自动更新寄存器。哪些寄存器被更新由可以重置的寄存器掩码确定。掩码应为在调用垃圾收集时持有堆地址的任何寄存器设置位；有关详细信息，请参见trap.handler文件。生成的代码必须通知收集器每次对属性的赋值。函数GenGC Assign接受更新的地址a在寄存器$a1中，并记录垃圾收集器需要的关于a的信息。例如，如果更新了$self寄存器偏移量12处的属性，则正确的代码序列是：

```c++
sw $x 12($self) addiu $a1 $self 12 jal _GenGC_Assign
```

调用GenGC_Assign可能会触发垃圾收集。请注意，如果未启用垃圾收集器，同样重要的是不要调用GenGC_Assign。

8.2 Register Mask
垃圾收集器在执行垃圾收集时会自动更新寄存器。哪些寄存器需要更新由一个可以重置的寄存器掩码决定。在调用垃圾收集时，掩码应为持有堆地址的任何寄存器设置位。有关详细信息，请参见trap.handler文件。